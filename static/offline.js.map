{"version":3,"sources":["webpack:///offline.js","webpack:///webpack/bootstrap ebc30118ef4aacd04cfb?bc1f","webpack:///./src/offline.js","webpack:///./~/offline-plugin/runtime.js","webpack:///./src/registerServiceWorker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","_interopRequireDefault","obj","__esModule","default","_registerServiceWorker","install","this","329","hasSW","navigator","window","fetch","document","documentElement","style","location","protocol","hostname","indexOf","options","serviceWorker","register","applicationCache","directory","name","doLoad","page","iframe","createElement","src","display","appCacheIframe","body","appendChild","readyState","setTimeout","addEventListener","applyUpdate","callback","errback","update","getRegistration","then","registration","contentWindow","e","414","self","event","waitUntil","skipWaiting","clients","claim","swUrl","console","log","onupdatefound","installingWorker","installing","onstatechange","state","controller","catch","error","unregister","ready","Object","defineProperty","value"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,UAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,UAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,IAGAV,EAAA,KDMMW,EACA,SAAUP,EAAQD,EAASH,GAE0e,gBAE1gB,YAMA,SAASY,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GEtDxF,GAAAG,GAAAhB,EAAA,IFoD+BY,GAAuBI,GErDtDhB,EAAQ,KAA0BiB,YF2DPV,KAAKW,MAAS,WAInCC,IACA,SAAUf,EAAQD,GG9DxB,QAAAiB,KACA,uBAAAC,aAGAC,OAAAC,OAAA,kBAAAC,UAAAC,gBAAAC,SACA,WAAAJ,OAAAK,SAAAC,UAAA,cAAAN,OAAAK,SAAAE,UAAA,IAAAP,OAAAK,SAAAE,SAAAC,QAAA,SAGA,QAAAb,GAAAc,GAIA,GAHAA,UAGAX,IACAC,UAAAW,cACAC,SACA,cAWA,IAAAX,OAAAY,iBAAA,CACA,GAAAC,GAAA,aACAC,EAAA,WAEAC,EAAA,WACA,GAAAC,GAAAH,EAAAC,EAAA,QACAG,EAAAf,SAAAgB,cAAA,SAIAD,GAAAE,IAAAH,EACAC,EAAAb,MAAAgB,QAAA,OAEAC,EAAAJ,EACAf,SAAAoB,KAAAC,YAAAN,GASA,aANA,aAAAf,SAAAsB,WACAC,WAAAV,GAEAf,OAAA0B,iBAAA,OAAAX,KAQA,QAAAY,GAAAC,EAAAC,IAMA,QAAAC,KAWA,GATAhC,KACAC,UAAAW,cAAAqB,kBAAAC,KAAA,SAAAC,GACA,GAAAA,EACA,MAAAA,GAAAH,WAMAT,EACA,IACAA,EAAAa,cAAAtB,iBAAAkB,SACO,MAAAK,KA5EP,GAAAd,EAmFAxC,GAAAc,UACAd,EAAA8C,cACA9C,EAAAiD,UHuEMM,IACA,SAAUtD,EAAQD,EAASH,GAE0e,gBAE1gB,YIvJc,SAASiC,KAEuB,iBAAmBZ,aAC9DsC,KAAKX,iBAAiB,UAAW,SAASY,GACxCA,EAAMC,UAAUF,KAAKG,iBAGvBH,KAAKX,iBAAiB,WAAY,SAASY,GACzCA,EAAMC,UAAUF,KAAKI,QAAQC,WAG/B1C,OAAO0B,iBAAiB,OAAQ,WAC9B,GAAMiB,GAAQ,mBACdC,SAAQC,IAAIF,GACZ5C,UAAUW,cACPC,SAASgC,GACTX,KAAK,SAAAC,GACJA,EAAaa,cAAgB,WAC3B,GAAMC,GAAmBd,EAAae,UACtCD,GAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfnD,UAAUW,cAAcyC,WAK1BP,QAAQC,IAAI,6CAKZD,QAAQC,IAAI,2CAMrBO,MAAM,SAAAC,GACLT,QAAQS,MAAM,4CAA6CA,QAM9D,QAASC,KACV,iBAAmBvD,YACrBA,UAAUW,cAAc6C,MAAMvB,KAAK,SAAAC,GACjCA,EAAaqB,eJ0GlBE,OAAOC,eAAe5E,EAAS,cAC7B6E,WAEF7E,EAAQY,QI5JekB,EJ6JvB9B,EIjHeyE,eJ6KWrE,KAAKW,MAAS","file":"offline.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-api/modules/index.js\"), RootInstanceProvider = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-loader/RootInstanceProvider.js\"), ReactMount = require(\"react-dom/lib/ReactMount\"), React = require(\"react\"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {\n\t\n\t'use strict';\n\t\n\tvar _registerServiceWorker = __webpack_require__(414);\n\t\n\tvar _registerServiceWorker2 = _interopRequireDefault(_registerServiceWorker);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t__webpack_require__(329).install();\n\t\n\t/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-loader/makeExportsHot.js\"); if (makeExportsHot(module, require(\"react\"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot apply hot update to \" + \"offline.js\" + \": \" + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }\n\n/***/ }),\n\n/***/ 329:\n/***/ (function(module, exports) {\n\n\tvar appCacheIframe;\n\t\n\tfunction hasSW() {\n\t  return 'serviceWorker' in navigator &&\n\t    // This is how I block Chrome 40 and detect Chrome 41, because first has\n\t    // bugs with history.pustState and/or hashchange\n\t    (window.fetch || 'imageRendering' in document.documentElement.style) &&\n\t    (window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname.indexOf('127.') === 0)\n\t}\n\t\n\tfunction install(options) {\n\t  options || (options = {});\n\t\n\t  \n\t    if (hasSW()) {\n\t      var registration = navigator.serviceWorker\n\t        .register(\n\t          \"/sw.js\"\n\t          \n\t        );\n\t\n\t      \n\t\n\t      return;\n\t    }\n\t  \n\t\n\t  \n\t    if (window.applicationCache) {\n\t      var directory = \"/appcache/\";\n\t      var name = \"manifest\";\n\t\n\t      var doLoad = function() {\n\t        var page = directory + name + '.html';\n\t        var iframe = document.createElement('iframe');\n\t\n\t        \n\t\n\t        iframe.src = page;\n\t        iframe.style.display = 'none';\n\t\n\t        appCacheIframe = iframe;\n\t        document.body.appendChild(iframe);\n\t      };\n\t\n\t      if (document.readyState === 'complete') {\n\t        setTimeout(doLoad);\n\t      } else {\n\t        window.addEventListener('load', doLoad);\n\t      }\n\t\n\t      return;\n\t    }\n\t  \n\t}\n\t\n\tfunction applyUpdate(callback, errback) {\n\t  \n\t\n\t  \n\t}\n\t\n\tfunction update() {\n\t  \n\t    if (hasSW()) {\n\t      navigator.serviceWorker.getRegistration().then(function(registration) {\n\t        if (!registration) return;\n\t        return registration.update();\n\t      });\n\t    }\n\t  \n\t\n\t  \n\t    if (appCacheIframe) {\n\t      try {\n\t        appCacheIframe.contentWindow.applicationCache.update();\n\t      } catch (e) {}\n\t    }\n\t  \n\t}\n\t\n\t\n\t\n\texports.install = install;\n\texports.applyUpdate = applyUpdate;\n\texports.update = update;\n\n\n/***/ }),\n\n/***/ 414:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* REACT HOT LOADER */ if (false) { (function () { var ReactHotAPI = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-api/modules/index.js\"), RootInstanceProvider = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-loader/RootInstanceProvider.js\"), ReactMount = require(\"react-dom/lib/ReactMount\"), React = require(\"react\"); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }, React); })(); } try { (function () {\n\t\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = register;\n\texports.unregister = unregister;\n\t// In production, we register a service worker to serve assets from local cache.\n\t\n\t// This lets the app load faster on subsequent visits in production, and gives\n\t// it offline capabilities. However, it also means that developers (and users)\n\t// will only see deployed updates on the \"N+1\" visit to a page, since previously\n\t// cached resources are updated in the background.\n\t\n\t// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n\t// This link also includes instructions on opting out of this behavior.\n\t\n\tfunction register() {\n\t  // Register the service worker\n\t  if ((\"production\") === 'production' && 'serviceWorker' in navigator) {\n\t    self.addEventListener('install', function (event) {\n\t      event.waitUntil(self.skipWaiting()); // Activate worker immediately\n\t    });\n\t\n\t    self.addEventListener('activate', function (event) {\n\t      event.waitUntil(self.clients.claim()); // Become available to all pages\n\t    });\n\t\n\t    window.addEventListener('load', function () {\n\t      var swUrl = 'service-worker.js';\n\t      console.log(swUrl);\n\t      navigator.serviceWorker.register(swUrl).then(function (registration) {\n\t        registration.onupdatefound = function () {\n\t          var installingWorker = registration.installing;\n\t          installingWorker.onstatechange = function () {\n\t            if (installingWorker.state === 'installed') {\n\t              if (navigator.serviceWorker.controller) {\n\t                // At this point, the old content will have been purged and\n\t                // the fresh content will have been added to the cache.\n\t                // It's the perfect time to display a \"New content is\n\t                // available; please refresh.\" message in your web app.\n\t                console.log('New content is available; please refresh.');\n\t              } else {\n\t                // At this point, everything has been precached.\n\t                // It's the perfect time to display a\n\t                // \"Content is cached for offline use.\" message.\n\t                console.log('Content is cached for offline use.');\n\t              }\n\t            }\n\t          };\n\t        };\n\t      }).catch(function (error) {\n\t        console.error('Error during service worker registration:', error);\n\t      });\n\t    });\n\t  }\n\t}\n\t\n\tfunction unregister() {\n\t  if ('serviceWorker' in navigator) {\n\t    navigator.serviceWorker.ready.then(function (registration) {\n\t      registration.unregister();\n\t    });\n\t  }\n\t}\n\t\n\t/* REACT HOT LOADER */ }).call(this); } finally { if (false) { (function () { var foundReactClasses = module.hot.data && module.hot.data.foundReactClasses || false; if (module.exports && module.makeHot) { var makeExportsHot = require(\"/home/someone/new-vanila-homepage/node_modules/react-hot-loader/makeExportsHot.js\"); if (makeExportsHot(module, require(\"react\"))) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot apply hot update to \" + \"registerServiceWorker.js\" + \": \" + err.message); } }); } } module.hot.dispose(function (data) { data.makeHot = module.makeHot; data.foundReactClasses = foundReactClasses; }); })(); } }\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// offline.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ebc30118ef4aacd04cfb","require('offline-plugin/runtime').install();\nimport registerServiceWorker from './registerServiceWorker';\n\n\n// WEBPACK FOOTER //\n// ./src/offline.js","var appCacheIframe;\n\nfunction hasSW() {\n  return 'serviceWorker' in navigator &&\n    // This is how I block Chrome 40 and detect Chrome 41, because first has\n    // bugs with history.pustState and/or hashchange\n    (window.fetch || 'imageRendering' in document.documentElement.style) &&\n    (window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname.indexOf('127.') === 0)\n}\n\nfunction install(options) {\n  options || (options = {});\n\n  \n    if (hasSW()) {\n      var registration = navigator.serviceWorker\n        .register(\n          \"/sw.js\"\n          \n        );\n\n      \n\n      return;\n    }\n  \n\n  \n    if (window.applicationCache) {\n      var directory = \"/appcache/\";\n      var name = \"manifest\";\n\n      var doLoad = function() {\n        var page = directory + name + '.html';\n        var iframe = document.createElement('iframe');\n\n        \n\n        iframe.src = page;\n        iframe.style.display = 'none';\n\n        appCacheIframe = iframe;\n        document.body.appendChild(iframe);\n      };\n\n      if (document.readyState === 'complete') {\n        setTimeout(doLoad);\n      } else {\n        window.addEventListener('load', doLoad);\n      }\n\n      return;\n    }\n  \n}\n\nfunction applyUpdate(callback, errback) {\n  \n\n  \n}\n\nfunction update() {\n  \n    if (hasSW()) {\n      navigator.serviceWorker.getRegistration().then(function(registration) {\n        if (!registration) return;\n        return registration.update();\n      });\n    }\n  \n\n  \n    if (appCacheIframe) {\n      try {\n        appCacheIframe.contentWindow.applicationCache.update();\n      } catch (e) {}\n    }\n  \n}\n\n\n\nexports.install = install;\nexports.applyUpdate = applyUpdate;\nexports.update = update;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/offline-plugin/runtime.js\n// module id = 329\n// module chunks = 6","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nexport default function register() {\n  // Register the service worker\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    self.addEventListener('install', function(event) {\n      event.waitUntil(self.skipWaiting()); // Activate worker immediately\n    });\n\n    self.addEventListener('activate', function(event) {\n      event.waitUntil(self.clients.claim()); // Become available to all pages\n    });\n\n    window.addEventListener('load', () => {\n      const swUrl = 'service-worker.js';\n      console.log(swUrl);\n      navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n          registration.onupdatefound = () => {\n            const installingWorker = registration.installing;\n            installingWorker.onstatechange = () => {\n              if (installingWorker.state === 'installed') {\n                if (navigator.serviceWorker.controller) {\n                  // At this point, the old content will have been purged and\n                  // the fresh content will have been added to the cache.\n                  // It's the perfect time to display a \"New content is\n                  // available; please refresh.\" message in your web app.\n                  console.log('New content is available; please refresh.');\n                } else {\n                  // At this point, everything has been precached.\n                  // It's the perfect time to display a\n                  // \"Content is cached for offline use.\" message.\n                  console.log('Content is cached for offline use.');\n                }\n              }\n            };\n          };\n        })\n        .catch(error => {\n          console.error('Error during service worker registration:', error);\n        });\n    });\n  }\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/registerServiceWorker.js"],"sourceRoot":""}